<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="px-overlay-behavior.html"/>
<link rel="import" href="px-overlay-container.html"/>

<dom-module id="px-overlay-content">
    <template strip-whitespace>
      <slot></slot>
    </template>
  </dom-module>

  <script>
    Polymer({

      is: 'px-overlay-content',
      behaviors: [
        PxOverlayBehavior.sharedProperties
      ],

      properties: {
        _content: Array,
        _id: String,
        _container: HTMLElement,
        eventNames: {
          type: Array,
          value: function() { return []; }
        },
        /**
        * Array of unique IDs generated for this comp. cleaned from global
        * store on detached
        */
        _uniqueIdsUsed: {
          type: Array,
          value: function() { return []; }
        },

        _isAttached: {
          type: Boolean,
          value: false
        },
        hoist: {
          type: Boolean,
          value: true
        }
      },

      observers: [
        '_hoistPropChanged(hoist)'
      ],

      attached: function() {
        // FIXME? is a requestIdleFeedback a good idea? Will modals ever start open?

        // dunno if we really need this, but seems like a good idea ¯\(º o)/¯
        Polymer.RenderStatus.afterNextRender(this, () => {
          this._id = this.generateRandomID('overlay_');
          // TODO, what if we have dynamic content, like dom repeat? Need to test
          this._content = Polymer.FlattenedNodesObserver.getFlattenedNodes(this);
          this._isAttached = true;
          this._hoistPropChanged(this.hoist);
        });

      },

      detached: function() {
        this._isAttached = false;

        if(this._container) {
          this._container.detachContent(this);
        }

        if(this._id) {
          window.Px.uniqueIds['overlay_'].splice(window.Px.uniqueIds['overlay_'].indexOf(this._id), 1);
        }

      },

      hoistOverlay: function() {
        const event = new CustomEvent('px-overlay-attachment-request', {
          bubbles: true,
          composed: true,
          cancelable: true
        });

        this.dispatchEvent(event);

        // If no container responded, create one
        if (!event.defaultPrevented) {
          const elem = document.createElement('px-overlay-container');
          elem.setAttribute('container-type', this.containerType);

          document.body.appendChild(elem);

          // dunno if we really need this, but seems like a good idea ¯\(º o)/¯
          Polymer.RenderStatus.afterNextRender(elem, () => {
            this.dispatchEvent(event);
          });
        }
      },

      /**
      * Generates a random id string.
      *
      * Takes a string prefix, then adds 10 random chars
      *
      * @param {string}
      * @return {id string}
      */
      generateRandomID: function(baseStr) {
        var id = baseStr || 'id_',
            abc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
            len = abc.length;

        for(var i = 0; i < 10; i++){
          id += abc.charAt(Math.floor(Math.random() * len));
        }

        window.Px = window.Px || {};
        window.Px.uniqueIds = window.Px.uniqueIds || {};
        window.Px.uniqueIds[baseStr] = window.Px.uniqueIds[baseStr] || [];

        if(window.Px.uniqueIds[baseStr].indexOf(id) !== -1) {
          //id exists, recreate it.
          return this.generateRandomID(baseStr);
        } else {
          window.Px.uniqueIds[baseStr].push(id);
        }

        return id;
      },

      _hoistPropChanged: function(hoist) {
        if(!this._isAttached) {
          return;
        }
        if(hoist && !this._container) {
          this.hoistOverlay();
        }

        if(!hoist && this._container) {
          this._container.detachContent(this);
          this._container = undefined;
          this._content.forEach(elem => {
            this.appendChild(elem);
          });
        }

      }

    });
  </script>